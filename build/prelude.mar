data Error.*: [] {
    Ensure: [\Char]
}

;;data String: #[Char]

;; ENSURE

func ensure_msg: (v: Bool, msg: \Char) -> () {
    if !v {
        throw(Error.Ensure [msg])
    }
}

func ensure: (v: Bool) -> () {
    ensure_msg(v, "ensure error")
}

;; STRING

func string_to_c: (s: \#[Char]) -> \Char {
    if s\[#s\-1] != '\0' {
        ensure(#s\ < ##s\)
        set s\[#s\] = '\0'
    }
    return(`s->buf`)
}

test {
    var p1 = string_to_c(\#['o','i','\0'])
    ensure(`strcmp(p1,"oi")` == 0)
    ensure(`strlen(p1)` == 2)

    var s2: #[3*Char] = #['o','i']
    var p2 = string_to_c(\s2)
    ensure(`strcmp(p2,"oi")` == 0)
    ensure(`strlen(p2)` == 2)

    var x = catch Error.Ensure {
        string_to_c(\#['o','i'])
    }
    ensure(x?Err)
}

func string_from_int: (v: Int) -> #[32*Char] {
    var ret: #[32*Char]
    `ret.cur = snprintf(ret.buf, 32, "%d", v)`
    return(ret)
}

test {
    var str = string_from_int(10)
    ensure(#str == 2)
    ensure(##str == 32)
    ensure(str[0] == '1')
    ensure(str[1] == '0')
    ensure(str[2] == '\0')
}
